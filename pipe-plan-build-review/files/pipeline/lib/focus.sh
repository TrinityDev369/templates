#!/bin/bash
# focus.sh — .claudeignore generation + context assembly
#
# Restricts what the agent can see per phase (via .claudeignore)
# and assembles codebase context from .claude/context/ files.
#
# Dependencies: bash 4+, python3 (for JSON parsing)

# Generate .claudeignore for a phase, restricting what the agent can see
# Usage: generate_claudeignore <phase_config_json> <worktree_dir> <slug>
generate_claudeignore() {
  local config_json="$1"
  local target_dir="$2"
  local slug="$3"
  local ignore_file="$target_dir/.claudeignore"

  # Extract focus arrays from phase config
  local includes excludes
  includes=$(python3 -c "
import json, sys
c = json.loads(sys.argv[1])
for p in c.get('focus', {}).get('include', []):
    print(p.replace('{{SLUG}}', sys.argv[2]).replace('{{DOMAIN}}', sys.argv[3]))
" "$config_json" "${slug:-}" "${DOMAIN:-}" 2>/dev/null)

  excludes=$(python3 -c "
import json, sys
for p in json.loads(sys.argv[1]).get('focus', {}).get('exclude', []):
    print(p)
" "$config_json" 2>/dev/null)

  # Build .claudeignore: exclude paths, then ignore-all, then un-ignore includes
  {
    echo "# Auto-generated by PBR pipeline — do not edit"
    echo "# Phase-specific focus: only included paths are visible"

    # Always-excluded paths
    while IFS= read -r excl; do
      [ -n "$excl" ] && echo "$excl"
    done <<< "$excludes"

    echo ""
    echo "# Ignore everything by default"
    echo "*"
    echo ""
    echo "# Allow included paths"

    # Un-ignore each include path and its parent dirs
    while IFS= read -r inc; do
      [ -z "$inc" ] && continue

      # Gitignore requires parent dirs to be un-ignored first
      local path_so_far=""
      IFS='/' read -ra segs <<< "$inc"
      local last_idx=$(( ${#segs[@]} - 1 ))

      for i in "${!segs[@]}"; do
        [ -z "${segs[$i]}" ] && continue
        # Skip the final segment if it's a file (path doesn't end with /)
        if [[ "$inc" != */ ]] && [ "$i" -eq "$last_idx" ]; then
          continue
        fi
        path_so_far="${path_so_far}${segs[$i]}/"
        echo "!${path_so_far}"
      done

      # Un-ignore the actual target
      if [[ "$inc" == */ ]]; then
        echo "!${inc}**"
      else
        echo "!${inc}"
      fi
    done <<< "$includes"

    # Essential files always visible
    echo ""
    echo "# Always visible"
    echo "!CLAUDE.md"
    echo "!.claude/"
    echo "!.claude/**"
    echo "!package.json"
    echo "!tsconfig.json"
  } > "$ignore_file"

  echo "$ignore_file"
}

# Assemble context from .claude/context/ files listed in the phase config
# Reads the contextFiles array from the phase's focus config and concatenates
# matching files from the project's .claude/context/ directory.
#
# Usage: assemble_phase_context <phase_config_json> <description> <project_root>
# Output: Markdown string with task description + codebase context sections
assemble_phase_context() {
  local config_json="$1"
  local description="$2"
  local project_root="$3"

  # Extract contextFiles list from phase config JSON
  local context_files
  context_files=$(python3 -c "
import json, sys
c = json.loads(sys.argv[1])
for f in c.get('focus', {}).get('contextFiles', []):
    print(f)
" "$config_json" 2>/dev/null)

  # Read each context file and concatenate with section headers
  local context=""
  while IFS= read -r fname; do
    [ -z "$fname" ] && continue
    local fpath="$project_root/.claude/context/$fname"
    if [ -f "$fpath" ]; then
      context="${context}$(cat "$fpath")\n\n"
    fi
  done <<< "$context_files"

  # Build the final context: task description + any codebase conventions found
  echo -e "## Task\n${description}\n\n## Codebase Conventions\n${context}"
}
